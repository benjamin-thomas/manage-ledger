#!/usr/bin/env ruby

load ENV.fetch('PAYEE_DATA_PATH')

require 'bundler'
require 'securerandom'
require 'date'

env = ENV['ENV'] || ''
Bundler.require(:default, env)

require 'optparse'

options = {}
OptionParser.new do |opts|
  pgm_name = File.basename($PROGRAM_NAME)
  opts.banner =<<~EOS
  ---
  This script helps you keep your ledger file synchronized with your bank's data.

  OFX file have a transaction id.

  By tagging a ledger entry with the transaction id given by your bank, we can
  ensure all the transactions of a given OFX file are present in the ledger file.

  This script halts on the first unsaved transaction, forcing the user to either
  copy/paste the given snippet, or update an existing transaction with the given ofx_id.

  This script does not write to the ledger file
  ---

  Usage: #{pgm_name} [OPTIONS] LEDGER_FILE OFX_FILE
  EOS

  opts.on('--from DATE', 'Ignore transactions before DATE') do |d|
    options[:from] = Date.parse(d)
  end

  opts.on('-v', '--verbose', 'Run verbosely') do |v|
    options[:verbose] = v
  end

end.parse!

ledger_path = ARGV[0] || exec("#{$PROGRAM_NAME} -h")
ofx_path = ARGV[1] || exec("#{$PROGRAM_NAME} -h")

[ledger_path, ofx_path].each do |path|
  unless File.file?(path)
    warn("Not a file: #{path}")
    exit 1
  end
end

ledger_content = File.read(ledger_path)
from = options[:from]
warn "Skipping transaction from: #{from}" if from

ofx = OfxParser::OfxParser.parse(File.open(ofx_path))

ts = ofx.bank_account.statement.transactions

amount_padding = 49 # Not 50 due to minus sign
ts.reverse.each do |t|
  if from
    next if t.date < from
  end
  if ledger_content.include?("ofx_id: #{t.fit_id}")
    warn "Transaction #{t.fit_id} already in the ledger file, skipping..."
    next
  end

  # previous_txs = ''
  # term = t.payee
  # res = while previous_txs.empty?
  #         previous_txs = `hledger reg Expenses desc:^'#{term}'$' --begin thisquarter`
  #         require 'pry' ; binding.pry
  #         term = term.split[0..-2].join(' ')
  #         break :not_found if term.empty?
  #       end
  # Use thisquarter, thisyear, all if empty
  # Or try everything first, and check if payee has same expenses account everywhere
  # if positive, check Income, not Expenses
  # if not found, try t.payee.split # 'PAYEE RANDOM
  # t.payee.split[0..-2].join(' ')
  # recurring transactions: hledger reg desc:'VIREMENT EMIS' amt:660
  # This builtin also matches, but only the last transaction : hledger print Expenses -m PAYEE
  # Implement memo field, or similar tag: hledger reg Expenses tag:memo=WEB
  re, p = PAYEE.find { |re, attrs| re.match(t.payee) }

  head = p&.fetch(:head) || t.payee
  account = p&.fetch(:account) || 'Expenses::???'

  debit_account = 'Assets:Bank'
  lines = []
  lines << "#{t.date.strftime('%Y-%m-%d')} #{head}"
  lines << "  ; guid: #{SecureRandom.uuid}"
  lines << "  ; #{t.memo} | #{t.payee}"
  lines << "  ; ofx_id: #{t.fit_id}"
  lines << "  #{debit_account}  #{t.amount.rjust(amount_padding-debit_account.length)}€  ; date: #{t.date.strftime('%Y-%m-%d')}"
  inverse_amount = if t.amount.start_with?('+')
                     t.amount.sub('+', '-')
                   elsif t.amount.start_with?('-')
                     t.amount.sub('-', '+')
                   else
                     fail 'Not possible'
                   end
  lines << "  #{account}  #{inverse_amount.rjust(amount_padding-account.length)}€"

  warn "\nFound missing transaction, copy-paste or paste the missing ofx_id (already copied)".red
  warn 'Use command below to find proper account quickly:'.red
  warn "\nhledger accounts ^Expenses | grep Car".yellow

  copy_paste_data = lines[2..-2].join("\n")
  IO.popen('xsel -ib', 'w') { |f| f << copy_paste_data }
  puts
  puts lines
  puts
  exit 1
end

balance_date = ofx.bank_account.balance_date

balance_date = balance_date.to_date if balance_date == balance_date.to_date

# last_date = ts.sort_by(&:date).last.date
min, max = ts.minmax { |a, b| a.date <=> b.date }
puts '---'
puts
puts "First transaction on  : #{min.date}"
puts "Last transaction on   : #{max.date}"
puts
puts "Balance on #{balance_date}: #{ofx.bank_account.balance}"
